// Generated by CoffeeScript 1.6.3
(function() {
  define(["perlin"], function(Perlin) {
    var Map;
    Map = {};
    Map.init = function(width, height) {
      var ary, i, _i, _ref;
      if (typeof Uint8Array !== "undefined" && Uint8Array !== null) {
        ary = new Uint8Array(width * height);
      } else {
        ary = new Array(width * height);
        for (i = _i = 0, _ref = width * height; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          ary[i] = Map.EMPTY;
        }
      }
      return {
        ary: ary,
        width: width,
        height: height,
        bases: []
      };
    };
    Map.squares = new Array(256);
    Map.squares[Map.EMPTY = 0] = {
      color: "#333"
    };
    Map.squares[Map.ROCK_1 = 10] = {
      color: "#aaa",
      toughness: 0.4,
      energy: 60
    };
    Map.squares[Map.ROCK_2 = 11] = {
      color: "#bbb",
      toughness: 0.5,
      mass: 30
    };
    Map.squares[Map.ROCK_3 = 12] = {
      color: "#ccc",
      toughness: 0.6,
      energy: 40,
      mass: 20
    };
    Map.squares[Map.ROCK_4 = 13] = {
      color: "#ddd",
      toughness: 0.5,
      energy: 60
    };
    Map.squares[Map.ROCK_5 = 14] = {
      color: "#eee",
      toughness: 0.5,
      energy: 40
    };
    Map.squares[Map.ROCK_6 = 15] = {
      color: "#999",
      toughness: 0.4,
      mass: 10
    };
    Map.squares[Map.CONCRETE = 20] = {
      color: "#ccc",
      toughness: 0.8
    };
    Map.squares[Map.STEEL = 30] = {
      color: "#669",
      toughness: 0.9
    };
    Map.squares[Map.TITANIUM = 31] = {
      color: "#558",
      toughness: 0.99
    };
    Map.squares[Map.GOLD = 32] = {
      color: "#ff0",
      toughness: 0.3,
      energy: 300
    };
    Map.squares[Map.VOID = 255] = {
      color: "#000"
    };
    Map.get = function(map, x, y) {
      if (!Map.contains(map, x, y)) {
        throw new Error("position out of map");
      }
      return map.ary[x * map.height + y];
    };
    Map.set = function(map, x, y, val) {
      if (!Map.contains(map, x, y)) {
        throw new Error("position out of map");
      }
      return map.ary[x * map.height + y] = val;
    };
    Map.setOrNothing = function(map, x, y, val) {
      if (Map.contains(map, x, y)) {
        return map.ary[x * map.height + y] = val;
      }
    };
    Map.contains = function(map, x, y) {
      if (!(x === Math.floor(x) && y === Math.floor(y))) {
        throw new Error("only integer coordinates allowed");
      }
      return x >= 0 && x < map.width && y >= 0 && y < map.height;
    };
    Map.BASE_SIZE = 8;
    Map.BASE_DOOR_SIZE = 2;
    Map.NODE_DENSITY = 1 / 3000;
    Map.ROCK_RATIO = 0.999;
    Map.DEPOSIT_COUNT = 10;
    Map.DEPOSIT_RADIUS = 4;
    Map.CHAMBER_SIZE = 8;
    Map.BUNKER_SIZE = 6;
    Map.gen = function(settings) {
      var base, baseCount, bases, height, map, node, nodeCount, web, width, x, y, _i, _j, _len, _len1, _ref;
      width = settings.mapWidth;
      height = settings.mapHeight;
      baseCount = settings.playerDefs.length;
      nodeCount = Math.floor(width * height * Map.NODE_DENSITY);
      map = Map.init(width, height);
      Map.gen.fillRock(map);
      web = Map.gen.pointWeb(baseCount + nodeCount, width - 1, height - 1);
      map.bases = bases = (function() {
        var _i, _len, _ref, _ref1, _results;
        _ref = web.slice(0, baseCount);
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          _ref1 = _ref[_i], x = _ref1.x, y = _ref1.y;
          _results.push({
            x: Math.floor(Math.min(width - Map.BASE_SIZE, Math.max(Map.BASE_SIZE, x))),
            y: Math.floor(Math.min(height - Map.BASE_SIZE, Math.max(Map.BASE_SIZE, y)))
          });
        }
        return _results;
      })();
      for (_i = 0, _len = bases.length; _i < _len; _i++) {
        base = bases[_i];
        Map.gen.base(map, base);
      }
      _ref = web.slice(baseCount);
      for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
        node = _ref[_j];
        Map.gen.node(map, node);
      }
      return map;
    };
    Map.gen.fillRock = function(map) {
      var perlin, x, y, _i, _j, _ref, _ref1;
      perlin = Perlin.gen(0xbeef, map.width, map.height, {
        octaves: 4,
        amp: 0.4
      });
      for (y = _i = 0, _ref = map.height; _i < _ref; y = _i += 1) {
        for (x = _j = 0, _ref1 = map.width; _j < _ref1; x = _j += 1) {
          if (perlin[y * map.width + x] > 0) {
            Map.set(map, x, y, Map.gen.rockSquare());
          }
        }
      }
      return void 0;
    };
    Map.gen.rockSquare = function() {
      var r;
      r = Math.random();
      if (r < Map.ROCK_RATIO) {
        switch (Math.floor(r / Map.ROCK_RATIO * 6)) {
          case 0:
            return Map.ROCK_1;
          case 1:
            return Map.ROCK_2;
          case 2:
            return Map.ROCK_3;
          case 3:
            return Map.ROCK_4;
          case 4:
            return Map.ROCK_5;
          case 5:
            return Map.ROCK_6;
        }
      } else {
        return Map.gen.preciousSquare();
      }
    };
    Map.gen.preciousSquare = function() {
      switch (Math.floor(Math.random() * 3)) {
        case 0:
          return Map.STEEL;
        case 1:
          return Map.TITANIUM;
        case 2:
          return Map.GOLD;
      }
    };
    Map.gen.base = function(map, base) {
      var dx, i, j, s, x, y, _i, _j, _k, _l, _ref, _ref1, _ref2;
      x = base.x, y = base.y;
      s = Map.BASE_SIZE;
      for (i = _i = 0; 0 <= s ? _i < s : _i > s; i = 0 <= s ? ++_i : --_i) {
        Map.set(map, x + i, y, Map.TITANIUM);
        Map.set(map, x + i, y + s - 1, Map.TITANIUM);
        Map.set(map, x, y + i, Map.TITANIUM);
        Map.set(map, x + s - 1, y + i, Map.TITANIUM);
      }
      for (i = _j = 1, _ref = s - 1; 1 <= _ref ? _j < _ref : _j > _ref; i = 1 <= _ref ? ++_j : --_j) {
        for (j = _k = 1, _ref1 = s - 1; 1 <= _ref1 ? _k < _ref1 : _k > _ref1; j = 1 <= _ref1 ? ++_k : --_k) {
          Map.set(map, x + i, y + j, Map.EMPTY);
        }
      }
      for (i = _l = 0, _ref2 = Map.BASE_DOOR_SIZE; 0 <= _ref2 ? _l < _ref2 : _l > _ref2; i = 0 <= _ref2 ? ++_l : --_l) {
        dx = x + Math.floor(s / 2 - Map.BASE_DOOR_SIZE / 2) + i;
        Map.set(map, dx, y, Map.EMPTY);
        Map.set(map, dx, y + s - 1, Map.EMPTY);
      }
      return void 0;
    };
    Map.gen.node = function(map, pos) {
      switch (Math.floor(Math.random() * 3)) {
        case 0:
          return Map.gen.deposit(map, pos);
        case 1:
          return Map.gen.chamber(map, pos);
        case 2:
          return Map.gen.bunker(map, pos);
      }
    };
    Map.gen.deposit = function(map, pos) {
      var angle, count, dist, i, x, y, _i;
      count = Math.ceil(Map.DEPOSIT_COUNT * (Math.random() + 0.5));
      for (i = _i = 0; 0 <= count ? _i < count : _i > count; i = 0 <= count ? ++_i : --_i) {
        angle = Math.random() * 2 * Math.PI;
        dist = Math.ceil(Map.DEPOSIT_RADIUS * (Math.random() + 0.5));
        x = Math.floor(Math.sin(angle) * dist + pos.x);
        y = Math.floor(Math.cos(angle) * dist + pos.y);
        if (Map.get(map, x, y) !== Map.EMPTY) {
          Map.set(map, x, y, Map.gen.preciousSquare());
        }
      }
      return void 0;
    };
    Map.gen.chamber = function(map, pos) {
      var h, w, x, y, _i, _j, _ref, _ref1, _ref2, _ref3;
      w = Math.ceil(Map.CHAMBER_SIZE * (Math.random() + 0.5));
      h = Math.ceil(Map.CHAMBER_SIZE * (Math.random() + 0.5));
      for (x = _i = _ref = pos.x, _ref1 = pos.x + w; _i < _ref1; x = _i += 1) {
        for (y = _j = _ref2 = pos.y, _ref3 = pos.y + h; _j < _ref3; y = _j += 1) {
          if (Map.contains(map, x, y)) {
            Map.set(map, x, y, Map.EMPTY);
          }
        }
      }
      return void 0;
    };
    Map.gen.bunker = function(map, pos) {
      var doorPos, doorX, doorY, h, w, wall, x, y, _i, _j, _k, _l, _len, _m, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8;
      w = Math.ceil(Map.BUNKER_SIZE * (Math.random() + 0.5));
      h = Math.ceil(Map.BUNKER_SIZE * (Math.random() + 0.5));
      wall = (function() {
        switch (Math.floor(Math.random() * 2)) {
          case 0:
            return Map.CONCRETE;
          default:
            return Map.STEEL;
        }
      })();
      for (x = _i = _ref = pos.x, _ref1 = pos.x + w; _i < _ref1; x = _i += 1) {
        Map.setOrNothing(map, x, pos.y, wall);
        Map.setOrNothing(map, x, pos.y + h - 1, wall);
      }
      for (y = _j = _ref2 = pos.y, _ref3 = pos.y + h; _j < _ref3; y = _j += 1) {
        Map.setOrNothing(map, pos.x, y, wall);
        Map.setOrNothing(map, pos.x + w - 1, y, wall);
      }
      for (x = _k = _ref4 = pos.x + 1, _ref5 = pos.x + w - 1; _k < _ref5; x = _k += 1) {
        for (y = _l = _ref6 = pos.y + 1, _ref7 = pos.y + h - 1; _l < _ref7; y = _l += 1) {
          Map.setOrNothing(map, x, y, Map.EMPTY);
        }
      }
      doorPos = Math.random() < 0.5 ? (doorX = pos.x + Math.floor(Math.random() * (w - 2)) + 1, doorY = Math.random() < 0.5 ? pos.y : pos.y + h - 1, [
        {
          x: doorX,
          y: doorY
        }, {
          x: doorX + 1,
          y: doorY
        }
      ]) : (doorX = Math.random() < 0.5 ? pos.x : pos.x + w - 1, doorY = pos.x + Math.floor(Math.random() * (h - 2)) + 1, [
        {
          x: doorX,
          y: doorY
        }, {
          x: doorX,
          y: doorY + 1
        }
      ]);
      for (_m = 0, _len = doorPos.length; _m < _len; _m++) {
        _ref8 = doorPos[_m], x = _ref8.x, y = _ref8.y;
        Map.setOrNothing(map, x, y, Map.EMPTY);
      }
      return void 0;
    };
    Map.gen.pointWeb = function(count, width, height) {
      var clampX, clampY, d, dx, dy, f, i, j, points, t, ux, uy, x, y, _i, _j, _k, _l, _len, _m, _ref, _ref1, _results;
      points = (function() {
        var _i, _results;
        _results = [];
        for (i = _i = 0; _i < count; i = _i += 1) {
          _results.push({
            x: Math.random() * width,
            y: Math.random() * height
          });
        }
        return _results;
      })();
      clampX = function(x) {
        return Math.max(0, Math.min(width, x));
      };
      clampY = function(y) {
        return Math.max(0, Math.min(height, y));
      };
      for (t = _i = 0; _i < 10; t = _i += 1) {
        for (i = _j = 0; _j < count; i = _j += 1) {
          dx = points[i].x - width / 2;
          dy = points[i].y - height / 2;
          points[i].x -= dx * 0.02 + 5 * (Math.random() - 0.5);
          points[i].y -= dy * 0.02 + 5 * (Math.random() - 0.5);
        }
        for (i = _k = 0; _k < count; i = _k += 1) {
          for (j = _l = _ref = i + 1; _l < count; j = _l += 1) {
            d = Map.dist(points[i], points[j]);
            ux = dx / d;
            uy = dy / d;
            f = 20 / d;
            points[i].x = clampX(points[i].x + ux * f);
            points[i].y = clampY(points[i].y + uy * f);
            points[j].x = clampX(points[j].x - ux * f);
            points[j].y = clampY(points[j].y - uy * f);
          }
        }
        void 0;
      }
      _results = [];
      for (_m = 0, _len = points.length; _m < _len; _m++) {
        _ref1 = points[_m], x = _ref1.x, y = _ref1.y;
        _results.push({
          x: Math.floor(x),
          y: Math.floor(y)
        });
      }
      return _results;
    };
    Map.dist = function(p1, p2) {
      var dx, dy;
      dx = p1.x - p2.x;
      dy = p1.y - p2.y;
      return Math.sqrt(dx * dx + dy * dy);
    };
    return Map;
  });

}).call(this);
