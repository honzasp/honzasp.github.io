// Generated by CoffeeScript 1.6.3
(function() {
  define(["perlin"], function(Perlin) {
    var Map;
    Map = {};
    Map.init = function(width, height) {
      var ary, i, _i, _ref;
      if (typeof Uint8Array !== "undefined" && Uint8Array !== null) {
        ary = new Uint8Array(width * height);
      } else {
        ary = new Array(width * height);
        for (i = _i = 0, _ref = width * height; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          ary[i] = Map.EMPTY;
        }
      }
      return {
        ary: ary,
        width: width,
        height: height,
        bases: []
      };
    };
    Map.squares = new Array(256);
    Map.squares[Map.EMPTY = 0] = {
      color: "#333333"
    };
    Map.squares[Map.ROCK_1 = 10] = {
      color: "#a39c89",
      toughness: 0.4,
      energy: 80,
      prob: 0.5
    };
    Map.squares[Map.ROCK_2 = 11] = {
      color: "#a79f8c",
      toughness: 0.5,
      mass: 30,
      prob: 0.4
    };
    Map.squares[Map.ROCK_3 = 12] = {
      color: "#aaa18b",
      toughness: 0.6,
      energy: 90,
      prob: 0.4
    };
    Map.squares[Map.ROCK_4 = 13] = {
      color: "#aea287",
      toughness: 0.5,
      energy: 60,
      prob: 0.3
    };
    Map.squares[Map.ROCK_5 = 14] = {
      color: "#a79b7e",
      toughness: 0.5,
      energy: 100,
      prob: 0.3
    };
    Map.squares[Map.ROCK_6 = 15] = {
      color: "#a69b83",
      toughness: 0.4,
      mass: 10,
      prob: 0.6
    };
    Map.squares[Map.CONCRETE = 20] = {
      color: "#a3a3a3",
      toughness: 0.998
    };
    Map.squares[Map.STEEL = 30] = {
      color: "#6f7989",
      toughness: 0.995
    };
    Map.squares[Map.TITANIUM = 31] = {
      color: "#6287b2",
      toughness: 0.999
    };
    Map.squares[Map.GOLD = 32] = {
      color: "#dfbe23",
      toughness: 0.3,
      energy: 300
    };
    Map.squares[Map.LEAD = 33] = {
      color: "#5b7380",
      toughness: 0.35,
      mass: 50
    };
    Map.squares[Map.VOID = 255] = {
      color: "#000000"
    };
    Map.get = function(map, x, y) {
      if (!Map.contains(map, x, y)) {
        throw new Error("position out of map");
      }
      return map.ary[x * map.height + y];
    };
    Map.set = function(map, x, y, val) {
      if (!Map.contains(map, x, y)) {
        throw new Error("position out of map");
      }
      return map.ary[x * map.height + y] = val;
    };
    Map.setOrNothing = function(map, x, y, val) {
      if (Map.contains(map, x, y)) {
        return map.ary[x * map.height + y] = val;
      }
    };
    Map.contains = function(map, x, y) {
      if (!(x === Math.floor(x) && y === Math.floor(y))) {
        throw new Error("only integer coordinates allowed");
      }
      return x >= 0 && x < map.width && y >= 0 && y < map.height;
    };
    Map.BASE_SIZE = 8;
    Map.BASE_DOOR_SIZE = 2;
    Map.NODE_DENSITY = 1 / 3000;
    Map.ROCK_RATIO = 0.997;
    Map.DEPOSIT_COUNT = 10;
    Map.DEPOSIT_RADIUS = 4;
    Map.CHAMBER_SIZE = 8;
    Map.BUNKER_SIZE = 6;
    Map.OCTAVES = 4;
    Map.gen = function(settings) {
      var base, baseCount, bases, height, map, node, nodeCount, rng, web, width, x, y, _i, _j, _len, _len1, _ref;
      width = settings.mapWidth;
      height = settings.mapHeight;
      baseCount = settings.playerDefs.length;
      nodeCount = Math.floor(width * height * Map.NODE_DENSITY);
      rng = new Map.Rng(settings.mapSeed);
      map = Map.init(width, height);
      Map.gen.fillRock(map, rng, settings);
      web = Map.gen.pointWeb(rng, baseCount + nodeCount, width - 1, height - 1);
      _ref = web.slice(baseCount);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        node = _ref[_i];
        Map.gen.node(map, rng, node);
      }
      map.bases = bases = (function() {
        var _j, _len1, _ref1, _ref2, _results;
        _ref1 = web.slice(0, baseCount);
        _results = [];
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          _ref2 = _ref1[_j], x = _ref2.x, y = _ref2.y;
          _results.push({
            x: Math.floor(Math.min(width - Map.BASE_SIZE, Math.max(Map.BASE_SIZE, x))),
            y: Math.floor(Math.min(height - Map.BASE_SIZE, Math.max(Map.BASE_SIZE, y)))
          });
        }
        return _results;
      })();
      for (_j = 0, _len1 = bases.length; _j < _len1; _j++) {
        base = bases[_j];
        Map.gen.base(map, rng, base);
      }
      return map;
    };
    Map.gen.fillRock = function(map, rng, settings) {
      var perlin, x, y, _i, _j, _ref, _ref1;
      perlin = Perlin.gen(rng.genInt24(), map.width, map.height, {
        octaves: Map.OCTAVES,
        amp: settings.mapAmp
      });
      for (y = _i = 0, _ref = map.height; _i < _ref; y = _i += 1) {
        for (x = _j = 0, _ref1 = map.width; _j < _ref1; x = _j += 1) {
          if (perlin[y * map.width + x] > settings.mapCaveLimit) {
            Map.set(map, x, y, Map.gen.rockSquare(rng));
          }
        }
      }
      return void 0;
    };
    Map.gen.rockSquare = function(rng) {
      var r;
      r = rng.gen();
      if (r < Map.ROCK_RATIO) {
        switch (Math.floor(r / Map.ROCK_RATIO * 6)) {
          case 0:
            return Map.ROCK_1;
          case 1:
            return Map.ROCK_2;
          case 2:
            return Map.ROCK_3;
          case 3:
            return Map.ROCK_4;
          case 4:
            return Map.ROCK_5;
          case 5:
            return Map.ROCK_6;
        }
      } else {
        return Map.gen.preciousSquare(rng);
      }
    };
    Map.gen.preciousSquare = function(rng) {
      switch (rng.genInt(4)) {
        case 0:
          return Map.STEEL;
        case 1:
          return Map.TITANIUM;
        case 2:
          return Map.GOLD;
        case 3:
          return Map.LEAD;
      }
    };
    Map.gen.base = function(map, rng, base) {
      var dx, i, j, s, x, y, _i, _j, _k, _l, _ref, _ref1, _ref2;
      x = base.x, y = base.y;
      s = Map.BASE_SIZE;
      for (i = _i = 0; 0 <= s ? _i < s : _i > s; i = 0 <= s ? ++_i : --_i) {
        Map.set(map, x + i, y, Map.TITANIUM);
        Map.set(map, x + i, y + s - 1, Map.TITANIUM);
        Map.set(map, x, y + i, Map.TITANIUM);
        Map.set(map, x + s - 1, y + i, Map.TITANIUM);
      }
      for (i = _j = 1, _ref = s - 1; 1 <= _ref ? _j < _ref : _j > _ref; i = 1 <= _ref ? ++_j : --_j) {
        for (j = _k = 1, _ref1 = s - 1; 1 <= _ref1 ? _k < _ref1 : _k > _ref1; j = 1 <= _ref1 ? ++_k : --_k) {
          Map.set(map, x + i, y + j, Map.EMPTY);
        }
      }
      for (i = _l = 0, _ref2 = Map.BASE_DOOR_SIZE; 0 <= _ref2 ? _l < _ref2 : _l > _ref2; i = 0 <= _ref2 ? ++_l : --_l) {
        dx = x + Math.floor(s / 2 - Map.BASE_DOOR_SIZE / 2) + i;
        Map.set(map, dx, y, Map.EMPTY);
        Map.set(map, dx, y + s - 1, Map.EMPTY);
      }
      return void 0;
    };
    Map.gen.node = function(map, rng, pos) {
      switch (rng.genInt(3)) {
        case 0:
          return Map.gen.deposit(map, rng, pos);
        case 1:
          return Map.gen.chamber(map, rng, pos);
        case 2:
          return Map.gen.bunker(map, rng, pos);
      }
    };
    Map.gen.deposit = function(map, rng, pos) {
      var angle, count, dist, i, x, y, _i;
      count = Math.ceil(Map.DEPOSIT_COUNT * (rng.gen() + 0.5));
      for (i = _i = 0; 0 <= count ? _i < count : _i > count; i = 0 <= count ? ++_i : --_i) {
        angle = rng.gen() * 2 * Math.PI;
        dist = Math.ceil(Map.DEPOSIT_RADIUS * (rng.gen() + 0.5));
        x = Math.floor(Math.sin(angle) * dist + pos.x);
        y = Math.floor(Math.cos(angle) * dist + pos.y);
        if (Map.contains(map, x, y) && Map.get(map, x, y) !== Map.EMPTY) {
          Map.set(map, x, y, Map.gen.preciousSquare(rng));
        }
      }
      return void 0;
    };
    Map.gen.chamber = function(map, rng, pos) {
      var h, w, x, y, _i, _j, _ref, _ref1, _ref2, _ref3;
      w = Math.ceil(Map.CHAMBER_SIZE * (rng.gen() + 0.5));
      h = Math.ceil(Map.CHAMBER_SIZE * (rng.gen() + 0.5));
      for (x = _i = _ref = pos.x, _ref1 = pos.x + w; _i < _ref1; x = _i += 1) {
        for (y = _j = _ref2 = pos.y, _ref3 = pos.y + h; _j < _ref3; y = _j += 1) {
          if (Map.contains(map, x, y)) {
            Map.set(map, x, y, Map.EMPTY);
          }
        }
      }
      return void 0;
    };
    Map.gen.bunker = function(map, rng, pos) {
      var doorPos, doorX, doorY, h, w, wall, x, y, _i, _j, _k, _l, _len, _m, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8;
      w = Math.ceil(Map.BUNKER_SIZE * (rng.gen() + 0.5));
      h = Math.ceil(Map.BUNKER_SIZE * (rng.gen() + 0.5));
      wall = (function() {
        switch (Math.floor(rng.gen() * 2)) {
          case 0:
            return Map.CONCRETE;
          default:
            return Map.STEEL;
        }
      })();
      for (x = _i = _ref = pos.x, _ref1 = pos.x + w; _i < _ref1; x = _i += 1) {
        Map.setOrNothing(map, x, pos.y, wall);
        Map.setOrNothing(map, x, pos.y + h - 1, wall);
      }
      for (y = _j = _ref2 = pos.y, _ref3 = pos.y + h; _j < _ref3; y = _j += 1) {
        Map.setOrNothing(map, pos.x, y, wall);
        Map.setOrNothing(map, pos.x + w - 1, y, wall);
      }
      for (x = _k = _ref4 = pos.x + 1, _ref5 = pos.x + w - 1; _k < _ref5; x = _k += 1) {
        for (y = _l = _ref6 = pos.y + 1, _ref7 = pos.y + h - 1; _l < _ref7; y = _l += 1) {
          Map.setOrNothing(map, x, y, Map.EMPTY);
        }
      }
      doorPos = rng.gen() < 0.5 ? (doorX = pos.x + Math.floor(rng.gen() * (w - 2)) + 1, doorY = rng.gen() < 0.5 ? pos.y : pos.y + h - 1, [
        {
          x: doorX,
          y: doorY
        }, {
          x: doorX + 1,
          y: doorY
        }
      ]) : (doorX = rng.gen() < 0.5 ? pos.x : pos.x + w - 1, doorY = pos.x + Math.floor(rng.gen() * (h - 2)) + 1, [
        {
          x: doorX,
          y: doorY
        }, {
          x: doorX,
          y: doorY + 1
        }
      ]);
      for (_m = 0, _len = doorPos.length; _m < _len; _m++) {
        _ref8 = doorPos[_m], x = _ref8.x, y = _ref8.y;
        Map.setOrNothing(map, x, y, Map.EMPTY);
      }
      return void 0;
    };
    Map.gen.pointWeb = function(rng, count, width, height) {
      var clampX, clampY, d, dx, dy, f, i, j, points, t, ux, uy, x, y, _i, _j, _k, _l, _len, _m, _ref, _ref1, _results;
      points = (function() {
        var _i, _results;
        _results = [];
        for (i = _i = 0; _i < count; i = _i += 1) {
          _results.push({
            x: rng.gen() * width,
            y: rng.gen() * height
          });
        }
        return _results;
      })();
      clampX = function(x) {
        return Math.max(0, Math.min(width, x));
      };
      clampY = function(y) {
        return Math.max(0, Math.min(height, y));
      };
      for (t = _i = 0; _i < 10; t = _i += 1) {
        for (i = _j = 0; _j < count; i = _j += 1) {
          dx = points[i].x - width / 2;
          dy = points[i].y - height / 2;
          points[i].x -= dx * 0.02 + 5 * (rng.gen() - 0.5);
          points[i].y -= dy * 0.02 + 5 * (rng.gen() - 0.5);
        }
        for (i = _k = 0; _k < count; i = _k += 1) {
          for (j = _l = _ref = i + 1; _l < count; j = _l += 1) {
            d = Map.dist(points[i], points[j]);
            ux = dx / d;
            uy = dy / d;
            f = 20 / d;
            points[i].x = clampX(points[i].x + ux * f);
            points[i].y = clampY(points[i].y + uy * f);
            points[j].x = clampX(points[j].x - ux * f);
            points[j].y = clampY(points[j].y - uy * f);
          }
        }
        void 0;
      }
      _results = [];
      for (_m = 0, _len = points.length; _m < _len; _m++) {
        _ref1 = points[_m], x = _ref1.x, y = _ref1.y;
        _results.push({
          x: Math.floor(x),
          y: Math.floor(y)
        });
      }
      return _results;
    };
    Map.dist = function(p1, p2) {
      var dx, dy;
      dx = p1.x - p2.x;
      dy = p1.y - p2.y;
      return Math.sqrt(dx * dx + dy * dy);
    };
    Map.Rng = function(strSeed) {
      var a, b, c, ch, i, _i, _ref, _ref1;
      _ref = [0xbeef, 0xdead, 0xb00], a = _ref[0], b = _ref[1], c = _ref[2];
      for (i = _i = 0, _ref1 = strSeed.length; _i < _ref1; i = _i += 1) {
        ch = strSeed.charCodeAt(i);
        a = c ^ (a << 13) ^ (b << 3) ^ ch;
        b = a ^ (b << 15) ^ (c << 2) ^ (ch >> 1);
        c = b ^ (c << 5) ^ (a << 13) ^ ch;
      }
      this.a = a;
      this.b = b;
      return this.c = c;
    };
    Map.Rng.prototype.genInt24 = function() {
      var x;
      this.a = this.a ^ (((this.b << 13) + (this.c * 6823)) | 0);
      this.b = this.b ^ (((this.c << 11) + (this.a * 7727)) | 0);
      this.c = this.c ^ (((this.a << 10) + (this.b * 7549)) | 0);
      x = ((this.a ^ 5297) + (this.b ^ 4447)) | 0;
      return (x * ((x * x) | 0 * 3209 + 3541)) & 0xffffff;
    };
    Map.Rng.prototype.gen = function() {
      return this.genInt24() / 0xffffff;
    };
    Map.Rng.prototype.genRange = function(from, to) {
      return from + this.gen() * (to - from);
    };
    Map.Rng.prototype.genInt = function(limit) {
      return Math.floor(this.gen() * limit);
    };
    Map.Rng.prototype.genIntRange = function(from, to) {
      return this.genInt(to - from) + from;
    };
    return Map;
  });

}).call(this);
