// Generated by CoffeeScript 1.6.3
(function() {
  define(["perlin"], function(Perlin) {
    var Map;
    Map = {};
    Map.init = function(width, height) {
      var ary, i, _i, _ref;
      if (typeof Uint8Array !== "undefined" && Uint8Array !== null) {
        ary = new Uint8Array(width * height);
      } else {
        ary = new Array(width * height);
        for (i = _i = 0, _ref = width * height; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          ary[i] = Map.EMPTY;
        }
      }
      return {
        ary: ary,
        width: width,
        height: height,
        bases: []
      };
    };
    Map.squares = new Array(256);
    Map.squares[Map.EMPTY = 0] = {
      color: "#333"
    };
    Map.squares[Map.ROCK_1 = 10] = {
      color: "#aaa",
      toughness: 0.4,
      energy: 60
    };
    Map.squares[Map.ROCK_2 = 11] = {
      color: "#bbb",
      toughness: 0.5,
      mass: 30
    };
    Map.squares[Map.ROCK_3 = 12] = {
      color: "#ccc",
      toughness: 0.6,
      energy: 40,
      mass: 20
    };
    Map.squares[Map.ROCK_4 = 13] = {
      color: "#ddd",
      toughness: 0.5,
      energy: 60
    };
    Map.squares[Map.ROCK_5 = 14] = {
      color: "#eee",
      toughness: 0.5,
      energy: 40
    };
    Map.squares[Map.ROCK_6 = 15] = {
      color: "#999",
      toughness: 0.4,
      mass: 10
    };
    Map.squares[Map.CONCRETE = 20] = {
      color: "#ccc",
      toughness: 0.8
    };
    Map.squares[Map.STEEL = 30] = {
      color: "#669",
      toughness: 0.9
    };
    Map.squares[Map.TITANIUM = 31] = {
      color: "#558",
      toughness: 0.99
    };
    Map.squares[Map.GOLD = 32] = {
      color: "#ff0",
      toughness: 0.3,
      energy: 300
    };
    Map.squares[Map.VOID = 255] = {
      color: "#000"
    };
    Map.get = function(map, x, y) {
      if (!Map.contains(map, x, y)) {
        throw new Error("position out of map");
      }
      return map.ary[x * map.height + y];
    };
    Map.set = function(map, x, y, val) {
      if (!Map.contains(map, x, y)) {
        throw new Error("position out of map");
      }
      return map.ary[x * map.height + y] = val;
    };
    Map.contains = function(map, x, y) {
      if (!(x === Math.floor(x) && y === Math.floor(y))) {
        throw new Error("only integer coordinates allowed");
      }
      return x >= 0 && x < map.width && y >= 0 && y < map.height;
    };
    Map.BASE_SIZE = 8;
    Map.BASE_DOOR_SIZE = 2;
    Map.NODE_DENSITY = 0 / 3000;
    Map.ROCK_RATIO = 0.999;
    Map.TUNNEL_MAX_WIDTH = 4;
    Map.TUNNEL_DENSITY = 0.0;
    Map.TUNNEL_SHORTEN_ATTEMPTS = 10;
    Map.gen = function(settings) {
      var base, baseCount, bases, height, map, nodeCount, width, x, y, _i, _len;
      width = settings.mapWidth;
      height = settings.mapHeight;
      baseCount = settings.playerDefs.length;
      nodeCount = Math.floor(width * height * Map.NODE_DENSITY);
      map = Map.init(width, height);
      Map.gen.fillRock(map);
      map.bases = bases = (function() {
        var _i, _len, _ref, _ref1, _results;
        _ref = Map.gen.pointWeb(baseCount, width - 1, height - 1);
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          _ref1 = _ref[_i], x = _ref1.x, y = _ref1.y;
          _results.push({
            x: Math.floor(Math.min(width - Map.BASE_SIZE, Math.max(Map.BASE_SIZE, x))),
            y: Math.floor(Math.min(height - Map.BASE_SIZE, Math.max(Map.BASE_SIZE, y)))
          });
        }
        return _results;
      })();
      for (_i = 0, _len = bases.length; _i < _len; _i++) {
        base = bases[_i];
        Map.gen.base(map, base);
      }
      return map;
    };
    Map.gen.fillRock = function(map) {
      var perlin, x, y, _i, _j, _ref, _ref1;
      perlin = Perlin.gen(0xbeef, map.width, map.height, {
        octaves: 4,
        amp: 0.4
      });
      for (y = _i = 0, _ref = map.height; _i < _ref; y = _i += 1) {
        for (x = _j = 0, _ref1 = map.width; _j < _ref1; x = _j += 1) {
          if (perlin[y * map.width + x] > 0) {
            Map.set(map, x, y, Map.gen.rockSquare());
          }
        }
      }
      return void 0;
    };
    Map.gen.rockSquare = function() {
      var r;
      r = Math.random();
      if (r < Map.ROCK_RATIO) {
        switch (Math.floor(r / Map.ROCK_RATIO * 6)) {
          case 0:
            return Map.ROCK_1;
          case 1:
            return Map.ROCK_2;
          case 2:
            return Map.ROCK_3;
          case 3:
            return Map.ROCK_4;
          case 4:
            return Map.ROCK_5;
          case 5:
            return Map.ROCK_6;
        }
      } else {
        switch (Math.floor((r - Map.ROCK_RATIO) / (1 - Map.ROCK_RATIO) * 3)) {
          case 0:
            return Map.STEEL;
          case 1:
            return Map.TITANIUM;
          case 2:
            return Map.GOLD;
        }
      }
    };
    Map.gen.base = function(map, base) {
      var dx, i, j, s, x, y, _i, _j, _k, _l, _ref, _ref1, _ref2;
      x = base.x, y = base.y;
      s = Map.BASE_SIZE;
      for (i = _i = 0; 0 <= s ? _i < s : _i > s; i = 0 <= s ? ++_i : --_i) {
        Map.set(map, x + i, y, Map.TITANIUM);
        Map.set(map, x + i, y + s - 1, Map.TITANIUM);
        Map.set(map, x, y + i, Map.TITANIUM);
        Map.set(map, x + s - 1, y + i, Map.TITANIUM);
      }
      for (i = _j = 1, _ref = s - 1; 1 <= _ref ? _j < _ref : _j > _ref; i = 1 <= _ref ? ++_j : --_j) {
        for (j = _k = 1, _ref1 = s - 1; 1 <= _ref1 ? _k < _ref1 : _k > _ref1; j = 1 <= _ref1 ? ++_k : --_k) {
          Map.set(map, x + i, y + j, Map.EMPTY);
        }
      }
      for (i = _l = 0, _ref2 = Map.BASE_DOOR_SIZE; 0 <= _ref2 ? _l < _ref2 : _l > _ref2; i = 0 <= _ref2 ? ++_l : --_l) {
        dx = x + Math.floor(s / 2 - Map.BASE_DOOR_SIZE / 2) + i;
        Map.set(map, dx, y, Map.EMPTY);
        Map.set(map, dx, y + s - 1, Map.EMPTY);
      }
      return void 0;
    };
    Map.gen.pointWeb = function(count, width, height) {
      var clampX, clampY, d, dx, dy, f, i, j, points, t, ux, uy, x, y, _i, _j, _k, _l, _len, _m, _ref, _ref1, _results;
      points = (function() {
        var _i, _results;
        _results = [];
        for (i = _i = 0; _i < count; i = _i += 1) {
          _results.push({
            x: Math.random() * width,
            y: Math.random() * height
          });
        }
        return _results;
      })();
      clampX = function(x) {
        return Math.max(0, Math.min(width, x));
      };
      clampY = function(y) {
        return Math.max(0, Math.min(height, y));
      };
      for (t = _i = 0; _i < 100; t = _i += 1) {
        for (i = _j = 0; _j < count; i = _j += 1) {
          dx = points[i].x - width / 2;
          dy = points[i].y - height / 2;
          points[i].x -= dx * 0.02 + 5 * (Math.random() - 0.5);
          points[i].y -= dy * 0.02 + 5 * (Math.random() - 0.5);
        }
        for (i = _k = 0; _k < count; i = _k += 1) {
          for (j = _l = _ref = i + 1; _l < count; j = _l += 1) {
            d = Map.dist(points[i], points[j]);
            ux = dx / d;
            uy = dy / d;
            f = 20 / d;
            points[i].x = clampX(points[i].x + ux * f);
            points[i].y = clampY(points[i].y + uy * f);
            points[j].x = clampX(points[j].x - ux * f);
            points[j].y = clampY(points[j].y - uy * f);
          }
        }
        void 0;
      }
      _results = [];
      for (_m = 0, _len = points.length; _m < _len; _m++) {
        _ref1 = points[_m], x = _ref1.x, y = _ref1.y;
        _results.push({
          x: Math.floor(x),
          y: Math.floor(y)
        });
      }
      return _results;
    };
    Map.dist = function(p1, p2) {
      var dx, dy;
      dx = p1.x - p2.x;
      dy = p1.y - p2.y;
      return Math.sqrt(dx * dx + dy * dy);
    };
    return Map;
  });

}).call(this);
