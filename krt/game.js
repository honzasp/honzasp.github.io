// Generated by CoffeeScript 1.6.3
(function() {
  define(["jquery", "map", "window", "tank", "collisions"], function($, Map, Window, Tank, Collisions) {
    var Game;
    return Game = (function() {
      Game.MAX_GARBAGE_RATIO = 0.5;

      function Game($root, settings) {
        var x, y, _i, _j,
          _this = this;
        this.settings = settings;
        this.dom = {};
        this.dom.$root = $root;
        this.dom.$main = $("<div />").appendTo(this.dom.$root);
        this.dom.$canvas = $("<canvas />").appendTo(this.dom.$main);
        this.map = new Map(this.settings["map width"], this.settings["map height"]);
        for (y = _i = 2; _i <= 20; y = ++_i) {
          for (x = _j = 3; _j <= 13; x = ++_j) {
            this.map.set(x, y, Map.ROCK);
          }
        }
        this.map.set(4, 3, Map.ROCK);
        this.ctx = this.dom.$canvas[0].getContext("2d");
        this.resize(800, 600);
        this.tanks = [
          new Tank(this, {
            x: 1.8,
            y: 2.0
          }), new Tank(this, {
            x: 3.0,
            y: 1.2
          })
        ];
        this.bullets = [];
        $(document).keydown(function(evt) {
          switch (evt.which) {
            case 87:
              return _this.tanks[0].acc = 1;
            case 83:
              return _this.tanks[0].acc = -1;
            case 65:
              return _this.tanks[0].rot = 1;
            case 68:
              return _this.tanks[0].rot = -1;
            case 81:
              return _this.tanks[0].fire(_this);
          }
        });
        $(document).keyup(function(evt) {
          switch (evt.which) {
            case 87:
              if (_this.tanks[0].acc > 0) {
                return _this.tanks[0].acc = 0;
              }
              break;
            case 83:
              if (_this.tanks[0].acc < 0) {
                return _this.tanks[0].acc = 0;
              }
              break;
            case 65:
              if (_this.tanks[0].rot > 0) {
                return _this.tanks[0].rot = 0;
              }
              break;
            case 68:
              if (_this.tanks[0].rot < 0) {
                return _this.tanks[0].rot = 0;
              }
          }
        });
        this.tickLen = 1.0 / this.settings["fps"];
      }

      Game.prototype.resize = function(width, height) {
        this.dom.$canvas.attr("width", width);
        this.dom.$canvas.attr("height", height);
        return this.dim = {
          width: width,
          height: height
        };
      };

      Game.prototype.tick = function() {
        this.update(this.tickLen);
        return this.draw();
      };

      Game.prototype.draw = function() {
        return new Window(this, this.tanks[0].pos, {
          x: 0,
          y: 0,
          w: this.dim.width,
          h: this.dim.height,
          scale: 16
        });
      };

      Game.prototype.update = function(t) {
        this.updateTanks(t);
        return this.updateBullets(t);
      };

      Game.prototype.updateBullets = function(t) {
        var deadCount, i, p, _i, _j, _ref, _ref1;
        deadCount = 0;
        for (i = _i = 0, _ref = this.bullets.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          if (!this.bullets[i].isDead) {
            Collisions.bullet(this.bullets[i], t, this.map, this.tanks);
            this.bullets[i].update(t);
          } else {
            deadCount += 1;
          }
        }
        if (deadCount > this.bullets * Game.MAX_GARBAGE_RATIO) {
          p = 0;
          for (i = _j = 0, _ref1 = this.bullets.length; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
            if (!this.bullets[i].isDead) {
              this.bullets[p] = this.bullets[i];
              p = p + 1;
            }
          }
          return this.bullets.length = p;
        }
      };

      Game.prototype.updateTanks = function(t) {
        var i, j, _i, _j, _k, _l, _ref, _ref1, _ref2, _ref3, _ref4;
        for (i = _i = 0, _ref = this.tanks.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          this.tanks[i].update(t);
        }
        for (i = _j = 0, _ref1 = this.tanks.length; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
          for (j = _k = _ref2 = i + 1, _ref3 = this.tanks.length; _ref2 <= _ref3 ? _k < _ref3 : _k > _ref3; j = _ref2 <= _ref3 ? ++_k : --_k) {
            Collisions.tankTank(this.tanks[i], this.tanks[j]);
          }
        }
        for (i = _l = 0, _ref4 = this.tanks.length; 0 <= _ref4 ? _l < _ref4 : _l > _ref4; i = 0 <= _ref4 ? ++_l : --_l) {
          Collisions.tankMap(this.tanks[i], this.map);
        }
        return void 0;
      };

      Game.prototype.start = function() {
        var _this = this;
        return setInterval((function() {
          return _this.tick();
        }), 1000 * this.tickLen);
      };

      return Game;

    })();
  });

}).call(this);
