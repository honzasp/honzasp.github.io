// Generated by CoffeeScript 1.6.3
(function() {
  define(["map", "weapon", "bullet", "game"], function(Map, Weapon, Bullet, Game) {
    var Tank;
    Tank = function(idx, x, y, angle) {
      if (angle == null) {
        angle = 0;
      }
      this.index = idx;
      this.pos = {
        x: x,
        y: y
      };
      this.angle = angle;
      this.vel = {
        x: 0,
        y: 0
      };
      this.acc = 0;
      this.rot = 0;
      this.firing = false;
      this.energy = Tank.MAX_ENERGY;
      this.weapons = [new Weapon(Weapon.MachineGun), new Weapon(Weapon.Autocannon), new Weapon(Weapon.HugeCannon)];
      return this.activeWeapon = 0;
    };
    Tank.RADIUS = 0.45;
    Tank.WALL_DISTANCE = 0.01;
    Tank.MASS = 100;
    Tank.FORCE = 1000;
    Tank.FRICTION = 100;
    Tank.ANGULAR_SPEED = 1.5 * Math.PI;
    Tank.FIRING_ANGULAR_SPEED = 0.5 * Math.PI;
    Tank.BUMP_FACTOR = 0.3;
    Tank.BULLET_DIST = 1.2;
    Tank.MAX_ENERGY = 100;
    Tank.prototype.change = function() {
      return this.activeWeapon = (this.activeWeapon + 1) % this.weapons.length;
    };
    Tank.prototype.fire = function(game) {
      var angle, posX, posY, relVelX, relVelY, spec;
      spec = this.weapons[this.activeWeapon].spec;
      if (this.energy > spec.energy) {
        this.energy -= spec.energy;
        this.weapons[this.activeWeapon].temperature = spec.cooldown;
      } else {
        return;
      }
      angle = this.angle + (2 * spec.angleVariance * Math.random()) - spec.angleVariance;
      posX = this.pos.x + Math.sin(angle) * Tank.RADIUS * Tank.BULLET_DIST;
      posY = this.pos.y + Math.cos(angle) * Tank.RADIUS * Tank.BULLET_DIST;
      relVelX = Math.sin(angle) * spec.bullet.speed;
      relVelY = Math.cos(angle) * spec.bullet.speed;
      game.bullets.push(new Bullet({
        x: posX,
        y: posY
      }, {
        x: this.vel.x + relVelX,
        y: this.vel.y + relVelY
      }, spec.bullet, this.index));
      return this.impulse({
        x: -relVelX * spec.bullet.mass,
        y: -relVelY * spec.bullet.mass
      });
    };
    Tank.prototype.damage = function(game, dmg, guilty) {
      if (guilty == null) {
        guilty = void 0;
      }
      if (this.energy > dmg) {
        return this.energy -= dmg;
      } else {
        this.energy = 0;
        return Game.tankDestroyed(game, this.index, guilty);
      }
    };
    Tank.prototype.impulse = function(imp) {
      this.vel.x += imp.x / Tank.MASS;
      return this.vel.y += imp.y / Tank.MASS;
    };
    Tank.prototype.update = function(game, t) {
      var forceX, forceY, weapon, _i, _len, _ref;
      _ref = this.weapons;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        weapon = _ref[_i];
        if (weapon.temperature > 0) {
          weapon.temperature -= t;
        }
      }
      forceX = -this.vel.x * Tank.FRICTION + this.acc * Math.sin(this.angle) * Tank.FORCE;
      forceY = -this.vel.y * Tank.FRICTION + this.acc * Math.cos(this.angle) * Tank.FORCE;
      this.vel.x += forceX * t / Tank.MASS;
      this.vel.y += forceY * t / Tank.MASS;
      this.pos.x += this.vel.x * t;
      this.pos.y += this.vel.y * t;
      if (this.firing) {
        this.angle += this.rot * Tank.FIRING_ANGULAR_SPEED * t;
        if (this.weapons[this.activeWeapon].temperature <= 0) {
          return this.fire(game);
        }
      } else {
        return this.angle += this.rot * Tank.ANGULAR_SPEED * t;
      }
    };
    Tank.prototype.draw = function(ctx) {
      ctx.save();
      ctx.translate(this.pos.x, this.pos.y);
      ctx.rotate(-this.angle);
      ctx.scale(Tank.RADIUS, Tank.RADIUS);
      ctx.beginPath();
      ctx.arc(0, 0, 1.0, 0, Math.PI * 2);
      ctx.fillStyle = "#833";
      ctx.fill();
      ctx.beginPath();
      ctx.moveTo(0.0, 0.6);
      ctx.lineTo(-0.4, -0.4);
      ctx.lineTo(0.4, -0.4);
      ctx.lineTo(0.0, 0.6);
      ctx.fillStyle = "#333";
      ctx.fill();
      return ctx.restore();
    };
    return Tank;
  });

}).call(this);
