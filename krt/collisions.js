// Generated by CoffeeScript 1.6.3
(function() {
  define(["map", "tank", "bullet", "particle", "weapon", "bonus"], function(Map, Tank, Bullet, Particle, Weapon, Bonus) {
    var Collisions, lineMap, lineTank, solveQuad;
    Collisions = {};
    Collisions.tankMap = function(tank, map) {
      var corner, edgeE, edgeN, edgeS, edgeW, isFull, pos, r, vel, x, y, _i, _j, _ref, _ref1, _ref2, _ref3;
      pos = {
        x: tank.pos.x,
        y: tank.pos.y
      };
      vel = {
        x: tank.vel.x,
        y: tank.vel.y
      };
      r = tank.radius;
      edgeW = function(x, y) {
        if (y < pos.y && pos.y < y + 1 && pos.x < x && pos.x + r > x) {
          pos.x = x - r - Tank.WALL_DISTANCE;
          return vel.x *= -Tank.BUMP_FACTOR;
        }
      };
      edgeE = function(x, y) {
        if (y < pos.y && pos.y < y + 1 && pos.x > x && pos.x - r < x) {
          pos.x = x + r + Tank.WALL_DISTANCE;
          return vel.x *= -Tank.BUMP_FACTOR;
        }
      };
      edgeN = function(x, y) {
        if (x < pos.x && pos.x < x + 1 && pos.y < y && pos.y + r > y) {
          pos.y = y - r - Tank.WALL_DISTANCE;
          return vel.y *= -Tank.BUMP_FACTOR;
        }
      };
      edgeS = function(x, y) {
        if (x < pos.x && pos.x < x + 1 && pos.y > y && pos.y - r < y) {
          pos.y = y + r + Tank.WALL_DISTANCE;
          return vel.y *= -Tank.BUMP_FACTOR;
        }
      };
      corner = function(x, y, isNorth, isWest) {
        var d;
        d = {
          x: x - pos.x,
          y: y - pos.y
        };
        if (d.x * d.x + d.y * d.y < r * r) {
          vel.x *= -Tank.BUMP_FACTOR;
          vel.y *= -Tank.BUMP_FACTOR;
          if (isNorth) {
            if (isWest) {
              pos.x += d.x - Math.sqrt(r * r - d.y * d.y);
              return pos.y += d.y - Math.sqrt(r * r - d.x * d.x);
            } else {
              pos.x += d.x + Math.sqrt(r * r - d.y * d.y);
              return pos.y += d.y - Math.sqrt(r * r - d.x * d.x);
            }
          } else {
            if (isWest) {
              pos.x += d.x - Math.sqrt(r * r - d.y * d.y);
              return pos.y += d.y + Math.sqrt(r * r - d.x * d.x);
            } else {
              pos.x += d.x + Math.sqrt(r * r - d.y * d.y);
              return pos.y += d.y + Math.sqrt(r * r - d.x * d.x);
            }
          }
        }
      };
      isFull = function(x, y) {
        return !Map.contains(map, x, y) || Map.get(map, x, y) !== Map.EMPTY;
      };
      for (x = _i = _ref = Math.floor(pos.x - r), _ref1 = Math.floor(pos.x + r); _ref <= _ref1 ? _i <= _ref1 : _i >= _ref1; x = _ref <= _ref1 ? ++_i : --_i) {
        for (y = _j = _ref2 = Math.floor(pos.y - r), _ref3 = Math.floor(pos.y + r); _ref2 <= _ref3 ? _j <= _ref3 : _j >= _ref3; y = _ref2 <= _ref3 ? ++_j : --_j) {
          if (isFull(x, y)) {
            edgeW(x, y);
            edgeE(x + 1, y);
            edgeN(x, y);
            edgeS(x, y + 1);
            corner(x, y, true, true);
            corner(x + 1, y, true, false);
            corner(x, y + 1, false, true);
            corner(x + 1, y + 1, false, false);
          }
        }
      }
      tank.pos = pos;
      return tank.vel = vel;
    };
    Collisions.tankTank = function(tank1, tank2) {
      var d, l, mom1, mom2, momP1, momP2, r1, r2, u;
      d = {
        x: tank1.pos.x - tank2.pos.x,
        y: tank1.pos.y - tank2.pos.y
      };
      l = Math.sqrt(d.x * d.x + d.y * d.y);
      r1 = tank1.radius;
      r2 = tank2.radius;
      if (l < r1 + r2) {
        u = {
          x: d.x / l,
          y: d.y / l
        };
        tank1.pos = {
          x: tank1.pos.x + u.x * (r1 - l / 2),
          y: tank1.pos.y + u.y * (r1 - l / 2)
        };
        tank2.pos = {
          x: tank2.pos.x - u.x * (r2 - l / 2),
          y: tank2.pos.y - u.y * (r2 - l / 2)
        };
        mom1 = {
          x: tank1.vel.x * tank1.mass,
          y: tank1.vel.y * tank1.mass
        };
        mom2 = {
          x: tank2.vel.x * tank2.mass,
          y: tank2.vel.y * tank2.mass
        };
        momP1 = mom1.x * u.y - mom1.y * u.x;
        momP2 = mom2.x * u.y - mom2.y * u.x;
        tank1.vel = {
          x: (momP1 * u.y + mom2.x - momP2 * u.y) / tank1.mass,
          y: (momP1 * (-u.x) + mom2.y - momP2 * (-u.x)) / tank1.mass
        };
        return tank2.vel = {
          x: (momP2 * u.y + mom1.x - momP1 * u.y) / tank2.mass,
          y: (momP2 * (-u.x) + mom1.y - momP1 * (-u.x)) / tank2.mass
        };
      }
    };
    lineMap = function(start, end, map) {
      var eastEdges, hit, northEdges, southEdges, wallHit, westEdges;
      wallHit = null;
      hit = function(x, y, mapX, mapY, d) {
        if (!(d >= 0)) {
          return;
        }
        if (!(mapX >= 0 && mapX < map.width && mapY >= 0 && mapY < map.height)) {
          return wallHit = {
            d: Infinity,
            pos: {
              x: x,
              y: y
            }
          };
        } else {
          if (Map.get(map, mapX, mapY) === Map.EMPTY) {
            return;
          }
          if (!wallHit || d < wallHit.d) {
            return wallHit = {
              d: d,
              pos: {
                x: x,
                y: y
              },
              map: {
                x: mapX,
                y: mapY
              }
            };
          }
        }
      };
      hit(start.x, start.y, Math.floor(start.x), Math.floor(start.y), 0);
      northEdges = function() {
        var d, x, y;
        y = Math.ceil(start.y);
        while (y < Math.ceil(end.y)) {
          d = (y - start.y) / (end.y - start.y);
          x = start.x + (end.x - start.x) * d;
          hit(x, y, Math.floor(x), y, d);
          y = y + 1;
        }
        return void 0;
      };
      southEdges = function() {
        var d, x, y;
        y = Math.floor(start.y) - 1;
        while (y > Math.floor(end.y)) {
          d = (start.y - y - 1) / (start.y - end.y);
          x = start.x + (end.x - start.x) * d;
          hit(x, y + 1, Math.floor(x), y, d);
          y = y - 1;
        }
        return void 0;
      };
      westEdges = function() {
        var d, x, y;
        x = Math.ceil(start.x);
        while (x < Math.ceil(end.x)) {
          d = (x - start.x) / (end.x - start.x);
          y = start.y + (end.y - start.y) * d;
          hit(x + 1, y, x, Math.floor(y), d);
          x = x + 1;
        }
        return void 0;
      };
      eastEdges = function() {
        var d, x, y;
        x = Math.floor(start.x) - 1;
        while (x > Math.floor(end.x)) {
          d = (start.x - x - 1) / (start.x - end.x);
          y = start.y + (end.y - start.y) * d;
          hit(x, y, x, Math.floor(y), d);
          x = x - 1;
        }
        return void 0;
      };
      if (false) {
        northEdges = function() {
          var d, x, y;
          y = Math.ceil(start.y);
          while (y <= Math.floor(end.y)) {
            d = (y - start.y) / (end.y - start.y);
            x = d * (end.x - start.x) + start.x;
            hit(x, y, Math.floor(x), y, d);
            y = y + 1;
          }
          return void 0;
        };
        southEdges = function() {
          return void 0;
        };
        westEdges = function() {
          return void 0;
        };
        eastEdges = function() {
          return void 0;
        };
      }
      northEdges();
      southEdges();
      westEdges();
      eastEdges();
      return wallHit;
    };
    lineTank = function(start, end, tank) {
      var d, ds, e, p, r, s, _ref;
      _ref = [start, end, tank.pos, tank.radius], s = _ref[0], e = _ref[1], p = _ref[2], r = _ref[3];
      ds = solveQuad((e.x - s.x) * (e.x - s.x) + (e.y - s.y) * (e.y - s.y), 2 * (e.x - s.x) * (s.x - p.x) + 2 * (e.y - s.y) * (s.y - p.y), (s.x - p.x) * (s.x - p.x) + (s.y - p.y) * (s.y - p.y) - r * r);
      ds = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = ds.length; _i < _len; _i++) {
          d = ds[_i];
          if (d >= 0 && d <= 1) {
            _results.push(d);
          }
        }
        return _results;
      })();
      d = ds.length === 2 ? Math.min(ds[0], ds[1]) : ds.length === 1 ? ds[0] : void 0;
      if (d != null) {
        return {
          d: d,
          pos: {
            x: s.x + d * (e.x - s.x),
            y: s.y + d * (e.y - s.y)
          },
          tank: tank
        };
      }
    };
    solveQuad = function(a, b, c) {
      var disc, discSqrt;
      disc = b * b - 4 * a * c;
      if (disc > 0) {
        discSqrt = Math.sqrt(disc);
        return [(-b - discSqrt) / (2 * a), (-b + discSqrt) / (2 * a)];
      } else if (disc === 0) {
        return [-b / (2 * a)];
      } else {
        return [];
      }
    };
    Collisions.bullet = function(bullet, game, t) {
      var angle, bonus, end, energy, fragment, fragmentCount, gain, i, m, map, mass, nearestHit, pos, posX, posY, radiusSinVel, spec, speed, start, tank, tankHit, tanks, toughness, vel, velX, velY, _i, _j, _len, _ref;
      tanks = game.tanks, map = game.map;
      start = {
        x: bullet.pos.x,
        y: bullet.pos.y
      };
      end = {
        x: bullet.pos.x + bullet.vel.x * t,
        y: bullet.pos.y + bullet.vel.y * t
      };
      if (Math.abs(end.x - start.x) < 0.001) {
        end.x = end.x + 0.001;
      }
      if (Math.abs(end.y - start.y) < 0.001) {
        end.y = end.y + 0.001;
      }
      nearestHit = lineMap(start, end, map);
      for (_i = 0, _len = tanks.length; _i < _len; _i++) {
        tank = tanks[_i];
        if (tankHit = lineTank(start, end, tank)) {
          if (!nearestHit || tankHit.d < nearestHit.d) {
            nearestHit = tankHit;
          }
        }
      }
      if (nearestHit) {
        bullet.isDead = true;
        spec = bullet.spec;
        if ((m = nearestHit.map) != null) {
          _ref = Map.squares[Map.get(map, m.x, m.y)], toughness = _ref.toughness, energy = _ref.energy, mass = _ref.mass;
          if (Math.pow(toughness, spec.damage) < Math.random()) {
            Map.set(map, m.x, m.y, Map.EMPTY);
            gain = (energy != null) && (((mass != null) && Math.random() < 0.5) || (mass == null)) ? {
              energy: energy * (0.5 + Math.random())
            } : mass != null ? {
              mass: mass * (0.5 + Math.random())
            } : void 0;
            if (gain != null) {
              pos = {
                x: m.x + 0.5,
                y: m.y + 0.5
              };
              angle = Math.random() * 2 * Math.PI;
              speed = Bonus.SPEED * (0.5 + Math.random());
              vel = {
                x: Math.sin(angle) * speed,
                y: Math.cos(angle) * speed
              };
              radiusSinVel = Bonus.RADIUS_SIN_VEL * (0.5 + Math.random());
              bonus = new Bonus(pos, vel, gain, radiusSinVel);
              game.bonuses.push(bonus);
            }
          }
        }
        if ((tank = nearestHit.tank) != null) {
          tank.impulse({
            x: bullet.vel.x * spec.mass,
            y: bullet.vel.y * spec.mass
          });
          tank.damage(game, spec.damage, bullet.owner);
        }
        if ((fragment = spec.fragment) != null) {
          fragmentCount = Math.floor(spec.mass / fragment.mass);
          for (i = _j = 0; 0 <= fragmentCount ? _j < fragmentCount : _j > fragmentCount; i = 0 <= fragmentCount ? ++_j : --_j) {
            angle = 2 * Math.PI * Math.random();
            posX = Math.sin(angle) * Weapon.FRAGMENT_RADIUS + nearestHit.pos.x;
            posY = Math.cos(angle) * Weapon.FRAGMENT_RADIUS + nearestHit.pos.y;
            velX = Math.sin(angle) * fragment.speed;
            velY = Math.cos(angle) * fragment.speed;
            bullet = new Bullet({
              x: nearestHit.pos.x,
              y: nearestHit.pos.y
            }, {
              x: velX,
              y: velY
            }, fragment, bullet.owner);
            game.bullets.push(bullet);
          }
        }
        spec.boom(game, nearestHit.pos);
      }
      return void 0;
    };
    Collisions.bonus = function(bonus, game, t) {
      var dx, dy, l, tank, _i, _len, _ref, _results;
      _ref = game.tanks;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        tank = _ref[_i];
        dx = tank.pos.x - bonus.pos.x;
        dy = tank.pos.y - bonus.pos.y;
        l = Math.sqrt(dx * dx + dy * dy);
        if (l < bonus.radius + tank.radius) {
          tank.receive(game, bonus.content);
          bonus.isDead = true;
          break;
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };
    return Collisions;
  });

}).call(this);
