// Generated by CoffeeScript 1.6.3
(function() {
  define(["map", "perlin"], function(Map, Perlin) {
    var MapGen;
    MapGen = {};
    MapGen.BASE_SIZE = 8;
    MapGen.BASE_DOOR_SIZE = 2;
    MapGen.NODE_DENSITY = 1 / 8000;
    MapGen.ROCK_RATIO = 0.997;
    MapGen.SHOT_SOUND_GAIN = 0.4;
    MapGen.DEPOSIT_COUNT = 10;
    MapGen.DEPOSIT_RADIUS = 4;
    MapGen.CHAMBER_SIZE = 8;
    MapGen.BUNKER_SIZE = 6;
    MapGen.FILL_OCTAVES = 4;
    MapGen.TYPE_OCTAVES = 4;
    MapGen.TYPE_AMP = 0.7;
    MapGen.TYPE_SCALE = 8;
    MapGen.gen = function(settings, callback) {
      var base, baseCount, bases, height, map, nodeCount, rng, width, x, y, _i, _j, _len, _len1, _ref, _ref1;
      width = settings.mapWidth;
      height = settings.mapHeight;
      baseCount = settings.playerDefs.length;
      nodeCount = Math.floor(width * height * MapGen.NODE_DENSITY);
      rng = new MapGen.Rng(settings.mapSeed);
      map = Map.init(width, height);
      MapGen.fillRock(map, rng, settings);
      _ref = MapGen.pointWeb(rng, nodeCount, width - 1, height - 1);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        _ref1 = _ref[_i], x = _ref1.x, y = _ref1.y;
        MapGen.node(map, rng, {
          x: x,
          y: y
        });
      }
      map.bases = bases = (function() {
        var _j, _len1, _ref2, _ref3, _results;
        _ref2 = MapGen.pointWeb(rng, baseCount, width, height);
        _results = [];
        for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
          _ref3 = _ref2[_j], x = _ref3.x, y = _ref3.y;
          _results.push({
            x: Math.floor(Math.min(width - MapGen.BASE_SIZE, Math.max(MapGen.BASE_SIZE, x))),
            y: Math.floor(Math.min(height - MapGen.BASE_SIZE, Math.max(MapGen.BASE_SIZE, y)))
          });
        }
        return _results;
      })();
      for (_j = 0, _len1 = bases.length; _j < _len1; _j++) {
        base = bases[_j];
        MapGen.base(map, rng, base);
      }
      return callback(map);
    };
    MapGen.fillRock = function(map, rng, settings) {
      var fillNoise, i, rockFamily, t0, t1, t2, typeNoises, x, y, _i, _j, _ref, _ref1;
      fillNoise = Perlin.gen(rng.genInt24(), map.width, map.height, {
        octaves: MapGen.FILL_OCTAVES,
        amp: settings.mapAmp
      });
      typeNoises = (function() {
        var _i, _results;
        _results = [];
        for (i = _i = 0; _i < 3; i = ++_i) {
          _results.push(Perlin.gen(rng.genInt24(), Math.ceil(map.width / MapGen.TYPE_SCALE) + 1, Math.ceil(map.height / MapGen.TYPE_SCALE) + 1, {
            octaves: MapGen.TYPE_OCTAVES,
            amp: MapGen.TYPE_AMP
          }));
        }
        return _results;
      })();
      for (y = _i = 0, _ref = map.height; _i < _ref; y = _i += 1) {
        for (x = _j = 0, _ref1 = map.width; _j < _ref1; x = _j += 1) {
          if (fillNoise.array[y * map.width + x] > settings.mapCaveLimit) {
            t0 = Perlin.interpolateOctave(typeNoises[0], x / MapGen.TYPE_SCALE, y / MapGen.TYPE_SCALE);
            t1 = Perlin.interpolateOctave(typeNoises[1], x / MapGen.TYPE_SCALE, y / MapGen.TYPE_SCALE);
            t2 = Perlin.interpolateOctave(typeNoises[2], x / MapGen.TYPE_SCALE, y / MapGen.TYPE_SCALE);
            rockFamily = t0 < t1 ? t1 < t2 ? 0 : t0 < t2 ? 1 : 4 : t2 < t1 ? 5 : t0 < t2 ? 2 : 3;
            Map.set(map, x, y, MapGen.rockSquare(rng, rockFamily));
          }
        }
      }
      return void 0;
    };
    MapGen.rockSquare = function(rng, rockFamily) {
      var r;
      r = rng.gen();
      if (r < MapGen.ROCK_RATIO) {
        return Map.rockId(rockFamily, Math.floor(r / MapGen.ROCK_RATIO * Map.ROCK_FAMILY_SIZE));
      } else {
        return MapGen.preciousSquare(rng);
      }
    };
    MapGen.preciousSquare = function(rng) {
      switch (rng.genInt(4)) {
        case 0:
          return Map.STEEL;
        case 1:
          return Map.TITANIUM;
        case 2:
          return Map.GOLD;
        case 3:
          return Map.LEAD;
      }
    };
    MapGen.base = function(map, rng, _arg) {
      var dx, i, j, s, x, y, _i, _j, _k, _l, _ref, _ref1, _ref2;
      x = _arg.x, y = _arg.y;
      s = MapGen.BASE_SIZE;
      for (i = _i = 0; 0 <= s ? _i < s : _i > s; i = 0 <= s ? ++_i : --_i) {
        Map.set(map, x + i, y, Map.TITANIUM);
        Map.set(map, x + i, y + s - 1, Map.TITANIUM);
        Map.set(map, x, y + i, Map.TITANIUM);
        Map.set(map, x + s - 1, y + i, Map.TITANIUM);
      }
      for (i = _j = 1, _ref = s - 1; 1 <= _ref ? _j < _ref : _j > _ref; i = 1 <= _ref ? ++_j : --_j) {
        for (j = _k = 1, _ref1 = s - 1; 1 <= _ref1 ? _k < _ref1 : _k > _ref1; j = 1 <= _ref1 ? ++_k : --_k) {
          Map.set(map, x + i, y + j, Map.EMPTY);
        }
      }
      for (i = _l = 0, _ref2 = MapGen.BASE_DOOR_SIZE; 0 <= _ref2 ? _l < _ref2 : _l > _ref2; i = 0 <= _ref2 ? ++_l : --_l) {
        dx = x + Math.floor(s / 2 - MapGen.BASE_DOOR_SIZE / 2) + i;
        Map.set(map, dx, y, Map.EMPTY);
        Map.set(map, dx, y + s - 1, Map.EMPTY);
      }
      return void 0;
    };
    MapGen.node = function(map, rng, pos) {
      switch (rng.genInt(5)) {
        case 0:
        case 1:
          return MapGen.deposit(map, rng, pos);
        case 2:
          return MapGen.chamber(map, rng, pos);
        case 3:
        case 4:
          return MapGen.bunker(map, rng, pos);
      }
    };
    MapGen.deposit = function(map, rng, pos) {
      var angle, count, dist, i, square, x, y, _i;
      count = Math.ceil(MapGen.DEPOSIT_COUNT * (rng.gen() + 0.5));
      square = MapGen.preciousSquare(rng);
      for (i = _i = 0; 0 <= count ? _i < count : _i > count; i = 0 <= count ? ++_i : --_i) {
        angle = rng.gen() * 2 * Math.PI;
        dist = Math.ceil(MapGen.DEPOSIT_RADIUS * (rng.gen() + 0.5));
        x = Math.floor(Math.sin(angle) * dist + pos.x);
        y = Math.floor(Math.cos(angle) * dist + pos.y);
        if (Map.contains(map, x, y) && Map.get(map, x, y) !== Map.EMPTY) {
          Map.set(map, x, y, square);
        }
      }
      return void 0;
    };
    MapGen.chamber = function(map, rng, pos) {
      var h, w, x, y, _i, _j, _ref, _ref1, _ref2, _ref3;
      w = Math.ceil(MapGen.CHAMBER_SIZE * (rng.gen() + 0.5));
      h = Math.ceil(MapGen.CHAMBER_SIZE * (rng.gen() + 0.5));
      for (x = _i = _ref = pos.x, _ref1 = pos.x + w; _i < _ref1; x = _i += 1) {
        for (y = _j = _ref2 = pos.y, _ref3 = pos.y + h; _j < _ref3; y = _j += 1) {
          if (Map.contains(map, x, y)) {
            Map.set(map, x, y, Map.EMPTY);
          }
        }
      }
      return void 0;
    };
    MapGen.bunker = function(map, rng, pos) {
      var doorPos, doorX, doorY, h, w, wall, x, y, _i, _j, _k, _l, _len, _m, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8;
      w = Math.ceil(MapGen.BUNKER_SIZE * (rng.gen() * 0.6 + 0.8));
      h = Math.ceil(MapGen.BUNKER_SIZE * (rng.gen() * 0.6 + 0.8));
      wall = (function() {
        switch (rng.genInt(9)) {
          case 0:
          case 1:
          case 2:
            return Map.CONCRETE;
          case 3:
          case 4:
          case 5:
            return Map.STEEL;
          case 6:
            return Map.TITANIUM;
          case 7:
            return Map.LEAD;
          case 8:
            return Map.GOLD;
        }
      })();
      for (x = _i = _ref = pos.x, _ref1 = pos.x + w - 1; _i <= _ref1; x = _i += 1) {
        Map.setOrNothing(map, x, pos.y, wall);
        Map.setOrNothing(map, x, pos.y + h - 1, wall);
      }
      for (y = _j = _ref2 = pos.y, _ref3 = pos.y + h - 1; _j <= _ref3; y = _j += 1) {
        Map.setOrNothing(map, pos.x, y, wall);
        Map.setOrNothing(map, pos.x + w - 1, y, wall);
      }
      for (x = _k = _ref4 = pos.x + 1, _ref5 = pos.x + w - 2; _k <= _ref5; x = _k += 1) {
        for (y = _l = _ref6 = pos.y + 1, _ref7 = pos.y + h - 2; _l <= _ref7; y = _l += 1) {
          Map.setOrNothing(map, x, y, Map.EMPTY);
        }
      }
      doorPos = rng.gen() < 0.5 ? (doorX = pos.x + rng.genInt(w - 2) + 1, doorY = rng.gen() < 0.5 ? pos.y : pos.y + h - 1, [
        {
          x: doorX,
          y: doorY
        }, {
          x: doorX + 1,
          y: doorY
        }
      ]) : (doorX = rng.gen() < 0.5 ? pos.x : pos.x + w - 1, doorY = pos.y + rng.genInt(h - 2) + 1, [
        {
          x: doorX,
          y: doorY
        }, {
          x: doorX,
          y: doorY + 1
        }
      ]);
      for (_m = 0, _len = doorPos.length; _m < _len; _m++) {
        _ref8 = doorPos[_m], x = _ref8.x, y = _ref8.y;
        Map.setOrNothing(map, x, y, Map.EMPTY);
      }
      return void 0;
    };
    MapGen.pointWeb = function(rng, count, width, height) {
      var clampX, clampY, d, dx, dy, f, i, j, points, t, ux, uy, x, y, _i, _j, _k, _l, _len, _m, _ref, _ref1, _results;
      points = (function() {
        var _i, _results;
        _results = [];
        for (i = _i = 0; _i < count; i = _i += 1) {
          _results.push({
            x: rng.gen() * width,
            y: rng.gen() * height
          });
        }
        return _results;
      })();
      clampX = function(x) {
        return Math.max(0, Math.min(width, x));
      };
      clampY = function(y) {
        return Math.max(0, Math.min(height, y));
      };
      for (t = _i = 0; _i < 10; t = _i += 1) {
        for (i = _j = 0; _j < count; i = _j += 1) {
          dx = points[i].x - width / 2;
          dy = points[i].y - height / 2;
          points[i].x -= dx * 0.01 + 5 * (rng.gen() - 0.5);
          points[i].y -= dy * 0.01 + 5 * (rng.gen() - 0.5);
        }
        for (i = _k = 0; _k < count; i = _k += 1) {
          for (j = _l = _ref = i + 1; _l < count; j = _l += 1) {
            d = MapGen.dist(points[i], points[j]);
            ux = dx / d;
            uy = dy / d;
            f = 30 / d;
            points[i].x = clampX(points[i].x + ux * f);
            points[i].y = clampY(points[i].y + uy * f);
            points[j].x = clampX(points[j].x - ux * f);
            points[j].y = clampY(points[j].y - uy * f);
          }
        }
        void 0;
      }
      _results = [];
      for (_m = 0, _len = points.length; _m < _len; _m++) {
        _ref1 = points[_m], x = _ref1.x, y = _ref1.y;
        _results.push({
          x: Math.floor(x),
          y: Math.floor(y)
        });
      }
      return _results;
    };
    MapGen.dist = function(p1, p2) {
      var dx, dy;
      dx = p1.x - p2.x;
      dy = p1.y - p2.y;
      return Math.sqrt(dx * dx + dy * dy);
    };
    MapGen.Rng = function(strSeed) {
      var a, b, c, ch, i, _i, _ref, _ref1;
      _ref = [0xbeef, 0xdead, 0xb00], a = _ref[0], b = _ref[1], c = _ref[2];
      for (i = _i = 0, _ref1 = strSeed.length; _i < _ref1; i = _i += 1) {
        ch = strSeed.charCodeAt(i);
        a = c ^ (a << 13) ^ (b << 3) ^ ch;
        b = a ^ (b << 15) ^ (c << 2) ^ (ch >> 1);
        c = b ^ (c << 5) ^ (a << 13) ^ ch;
      }
      this.a = a;
      this.b = b;
      return this.c = c;
    };
    MapGen.Rng.prototype.genInt24 = function() {
      var x;
      this.a = this.a ^ (((this.b << 13) + (this.c * 6823)) | 0);
      this.b = this.b ^ (((this.c << 11) + (this.a * 7727)) | 0);
      this.c = this.c ^ (((this.a << 10) + (this.b * 7549)) | 0);
      x = ((this.a ^ 5297) + (this.b ^ 4447)) | 0;
      return (x * ((x * x) | 0 * 3209 + 3541)) & 0xffffff;
    };
    MapGen.Rng.prototype.gen = function() {
      return this.genInt24() / 0xffffff;
    };
    MapGen.Rng.prototype.genRange = function(from, to) {
      return from + this.gen() * (to - from);
    };
    MapGen.Rng.prototype.genInt = function(limit) {
      return Math.floor(this.gen() * limit);
    };
    MapGen.Rng.prototype.genIntRange = function(from, to) {
      return this.genInt(to - from) + from;
    };
    return MapGen;
  });

}).call(this);
