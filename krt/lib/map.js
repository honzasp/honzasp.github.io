// Generated by CoffeeScript 1.6.3
(function() {
  define(["perlin"], function(Perlin) {
    var Map, i, t, _i, _j, _ref, _ref1;
    Map = {};
    Map.init = function(width, height) {
      var ary, i, _i, _ref;
      if (typeof Uint8Array !== "undefined" && Uint8Array !== null) {
        ary = new Uint8Array(width * height);
      } else {
        ary = new Array(width * height);
        for (i = _i = 0, _ref = width * height; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          ary[i] = Map.EMPTY;
        }
      }
      return {
        ary: ary,
        width: width,
        height: height,
        bases: []
      };
    };
    Map.get = function(map, x, y) {
      if (!Map.contains(map, x, y)) {
        throw new Error("position out of map");
      }
      return map.ary[x * map.height + y];
    };
    Map.set = function(map, x, y, val) {
      if (!Map.contains(map, x, y)) {
        throw new Error("position out of map");
      }
      return map.ary[x * map.height + y] = val;
    };
    Map.setOrNothing = function(map, x, y, val) {
      if (Map.contains(map, x, y)) {
        return map.ary[x * map.height + y] = val;
      }
    };
    Map.contains = function(map, x, y) {
      if (!(x === Math.floor(x) && y === Math.floor(y))) {
        throw new Error("only integer coordinates allowed");
      }
      return x >= 0 && x < map.width && y >= 0 && y < map.height;
    };
    Map.BASE_SIZE = 8;
    Map.BASE_DOOR_SIZE = 2;
    Map.NODE_DENSITY = 1 / 8000;
    Map.ROCK_RATIO = 0.997;
    Map.DEPOSIT_COUNT = 10;
    Map.DEPOSIT_RADIUS = 4;
    Map.CHAMBER_SIZE = 8;
    Map.BUNKER_SIZE = 6;
    Map.FILL_OCTAVES = 4;
    Map.TYPE_OCTAVES = 4;
    Map.TYPE_AMP = 0.7;
    Map.TYPE_SCALE = 8;
    Map.gen = function(settings) {
      var base, baseCount, bases, height, map, nodeCount, rng, width, x, y, _i, _j, _len, _len1, _ref, _ref1;
      width = settings.mapWidth;
      height = settings.mapHeight;
      baseCount = settings.playerDefs.length;
      nodeCount = Math.floor(width * height * Map.NODE_DENSITY);
      rng = new Map.Rng(settings.mapSeed);
      map = Map.init(width, height);
      Map.gen.fillRock(map, rng, settings);
      _ref = Map.gen.pointWeb(rng, nodeCount, width - 1, height - 1);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        _ref1 = _ref[_i], x = _ref1.x, y = _ref1.y;
        Map.gen.node(map, rng, {
          x: x,
          y: y
        });
      }
      map.bases = bases = (function() {
        var _j, _len1, _ref2, _ref3, _results;
        _ref2 = Map.gen.pointWeb(rng, baseCount, width, height);
        _results = [];
        for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
          _ref3 = _ref2[_j], x = _ref3.x, y = _ref3.y;
          _results.push({
            x: Math.floor(Math.min(width - Map.BASE_SIZE, Math.max(Map.BASE_SIZE, x))),
            y: Math.floor(Math.min(height - Map.BASE_SIZE, Math.max(Map.BASE_SIZE, y)))
          });
        }
        return _results;
      })();
      for (_j = 0, _len1 = bases.length; _j < _len1; _j++) {
        base = bases[_j];
        Map.gen.base(map, rng, base);
      }
      return map;
    };
    Map.gen.fillRock = function(map, rng, settings) {
      var fillNoise, i, rockType, t0, t1, t2, typeNoises, x, y, _i, _j, _ref, _ref1;
      fillNoise = Perlin.gen(rng.genInt24(), map.width, map.height, {
        octaves: Map.FILL_OCTAVES,
        amp: settings.mapAmp
      });
      typeNoises = (function() {
        var _i, _results;
        _results = [];
        for (i = _i = 0; _i < 3; i = ++_i) {
          _results.push(Perlin.gen(rng.genInt24(), Math.ceil(map.width / Map.TYPE_SCALE) + 1, Math.ceil(map.height / Map.TYPE_SCALE) + 1, {
            octaves: Map.TYPE_OCTAVES,
            amp: Map.TYPE_AMP
          }));
        }
        return _results;
      })();
      for (y = _i = 0, _ref = map.height; _i < _ref; y = _i += 1) {
        for (x = _j = 0, _ref1 = map.width; _j < _ref1; x = _j += 1) {
          if (fillNoise.array[y * map.width + x] > settings.mapCaveLimit) {
            t0 = Perlin.interpolateOctave(typeNoises[0], x / Map.TYPE_SCALE, y / Map.TYPE_SCALE);
            t1 = Perlin.interpolateOctave(typeNoises[1], x / Map.TYPE_SCALE, y / Map.TYPE_SCALE);
            t2 = Perlin.interpolateOctave(typeNoises[2], x / Map.TYPE_SCALE, y / Map.TYPE_SCALE);
            rockType = t0 < t1 ? t1 < t2 ? 0 : t0 < t2 ? 1 : 4 : t2 < t1 ? 5 : t0 < t2 ? 2 : 3;
            Map.set(map, x, y, Map.gen.rockSquare(rng, rockType));
          }
        }
      }
      return void 0;
    };
    Map.gen.rockSquare = function(rng, rockType) {
      var r;
      r = rng.gen();
      if (r < Map.ROCK_RATIO) {
        return Map.rockId(rockType, Math.floor(r / Map.ROCK_RATIO * Map.ROCK_TYPE_SIZE));
      } else {
        return Map.gen.preciousSquare(rng);
      }
    };
    Map.gen.preciousSquare = function(rng) {
      switch (rng.genInt(4)) {
        case 0:
          return Map.STEEL;
        case 1:
          return Map.TITANIUM;
        case 2:
          return Map.GOLD;
        case 3:
          return Map.LEAD;
      }
    };
    Map.gen.base = function(map, rng, _arg) {
      var dx, i, j, s, x, y, _i, _j, _k, _l, _ref, _ref1, _ref2;
      x = _arg.x, y = _arg.y;
      s = Map.BASE_SIZE;
      for (i = _i = 0; 0 <= s ? _i < s : _i > s; i = 0 <= s ? ++_i : --_i) {
        Map.set(map, x + i, y, Map.TITANIUM);
        Map.set(map, x + i, y + s - 1, Map.TITANIUM);
        Map.set(map, x, y + i, Map.TITANIUM);
        Map.set(map, x + s - 1, y + i, Map.TITANIUM);
      }
      for (i = _j = 1, _ref = s - 1; 1 <= _ref ? _j < _ref : _j > _ref; i = 1 <= _ref ? ++_j : --_j) {
        for (j = _k = 1, _ref1 = s - 1; 1 <= _ref1 ? _k < _ref1 : _k > _ref1; j = 1 <= _ref1 ? ++_k : --_k) {
          Map.set(map, x + i, y + j, Map.EMPTY);
        }
      }
      for (i = _l = 0, _ref2 = Map.BASE_DOOR_SIZE; 0 <= _ref2 ? _l < _ref2 : _l > _ref2; i = 0 <= _ref2 ? ++_l : --_l) {
        dx = x + Math.floor(s / 2 - Map.BASE_DOOR_SIZE / 2) + i;
        Map.set(map, dx, y, Map.EMPTY);
        Map.set(map, dx, y + s - 1, Map.EMPTY);
      }
      return void 0;
    };
    Map.gen.node = function(map, rng, pos) {
      switch (rng.genInt(5)) {
        case 0:
        case 1:
          return Map.gen.deposit(map, rng, pos);
        case 2:
          return Map.gen.chamber(map, rng, pos);
        case 3:
        case 4:
          return Map.gen.bunker(map, rng, pos);
      }
    };
    Map.gen.deposit = function(map, rng, pos) {
      var angle, count, dist, i, square, x, y, _i;
      count = Math.ceil(Map.DEPOSIT_COUNT * (rng.gen() + 0.5));
      square = Map.gen.preciousSquare(rng);
      for (i = _i = 0; 0 <= count ? _i < count : _i > count; i = 0 <= count ? ++_i : --_i) {
        angle = rng.gen() * 2 * Math.PI;
        dist = Math.ceil(Map.DEPOSIT_RADIUS * (rng.gen() + 0.5));
        x = Math.floor(Math.sin(angle) * dist + pos.x);
        y = Math.floor(Math.cos(angle) * dist + pos.y);
        if (Map.contains(map, x, y) && Map.get(map, x, y) !== Map.EMPTY) {
          Map.set(map, x, y, square);
        }
      }
      return void 0;
    };
    Map.gen.chamber = function(map, rng, pos) {
      var h, w, x, y, _i, _j, _ref, _ref1, _ref2, _ref3;
      w = Math.ceil(Map.CHAMBER_SIZE * (rng.gen() + 0.5));
      h = Math.ceil(Map.CHAMBER_SIZE * (rng.gen() + 0.5));
      for (x = _i = _ref = pos.x, _ref1 = pos.x + w; _i < _ref1; x = _i += 1) {
        for (y = _j = _ref2 = pos.y, _ref3 = pos.y + h; _j < _ref3; y = _j += 1) {
          if (Map.contains(map, x, y)) {
            Map.set(map, x, y, Map.EMPTY);
          }
        }
      }
      return void 0;
    };
    Map.gen.bunker = function(map, rng, pos) {
      var doorPos, doorX, doorY, h, w, wall, x, y, _i, _j, _k, _l, _len, _m, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8;
      w = Math.ceil(Map.BUNKER_SIZE * (rng.gen() * 0.6 + 0.8));
      h = Math.ceil(Map.BUNKER_SIZE * (rng.gen() * 0.6 + 0.8));
      wall = (function() {
        switch (rng.genInt(9)) {
          case 0:
          case 1:
          case 2:
            return Map.CONCRETE;
          case 3:
          case 4:
          case 5:
            return Map.STEEL;
          case 6:
            return Map.TITANIUM;
          case 7:
            return Map.LEAD;
          case 8:
            return Map.GOLD;
        }
      })();
      for (x = _i = _ref = pos.x, _ref1 = pos.x + w - 1; _i <= _ref1; x = _i += 1) {
        Map.setOrNothing(map, x, pos.y, wall);
        Map.setOrNothing(map, x, pos.y + h - 1, wall);
      }
      for (y = _j = _ref2 = pos.y, _ref3 = pos.y + h - 1; _j <= _ref3; y = _j += 1) {
        Map.setOrNothing(map, pos.x, y, wall);
        Map.setOrNothing(map, pos.x + w - 1, y, wall);
      }
      for (x = _k = _ref4 = pos.x + 1, _ref5 = pos.x + w - 2; _k <= _ref5; x = _k += 1) {
        for (y = _l = _ref6 = pos.y + 1, _ref7 = pos.y + h - 2; _l <= _ref7; y = _l += 1) {
          Map.setOrNothing(map, x, y, Map.EMPTY);
        }
      }
      doorPos = rng.gen() < 0.5 ? (doorX = pos.x + rng.genInt(w - 2) + 1, doorY = rng.gen() < 0.5 ? pos.y : pos.y + h - 1, [
        {
          x: doorX,
          y: doorY
        }, {
          x: doorX + 1,
          y: doorY
        }
      ]) : (doorX = rng.gen() < 0.5 ? pos.x : pos.x + w - 1, doorY = pos.y + rng.genInt(h - 2) + 1, [
        {
          x: doorX,
          y: doorY
        }, {
          x: doorX,
          y: doorY + 1
        }
      ]);
      for (_m = 0, _len = doorPos.length; _m < _len; _m++) {
        _ref8 = doorPos[_m], x = _ref8.x, y = _ref8.y;
        Map.setOrNothing(map, x, y, Map.EMPTY);
      }
      return void 0;
    };
    Map.gen.pointWeb = function(rng, count, width, height) {
      var clampX, clampY, d, dx, dy, f, i, j, points, t, ux, uy, x, y, _i, _j, _k, _l, _len, _m, _ref, _ref1, _results;
      points = (function() {
        var _i, _results;
        _results = [];
        for (i = _i = 0; _i < count; i = _i += 1) {
          _results.push({
            x: rng.gen() * width,
            y: rng.gen() * height
          });
        }
        return _results;
      })();
      clampX = function(x) {
        return Math.max(0, Math.min(width, x));
      };
      clampY = function(y) {
        return Math.max(0, Math.min(height, y));
      };
      for (t = _i = 0; _i < 10; t = _i += 1) {
        for (i = _j = 0; _j < count; i = _j += 1) {
          dx = points[i].x - width / 2;
          dy = points[i].y - height / 2;
          points[i].x -= dx * 0.01 + 5 * (rng.gen() - 0.5);
          points[i].y -= dy * 0.01 + 5 * (rng.gen() - 0.5);
        }
        for (i = _k = 0; _k < count; i = _k += 1) {
          for (j = _l = _ref = i + 1; _l < count; j = _l += 1) {
            d = Map.dist(points[i], points[j]);
            ux = dx / d;
            uy = dy / d;
            f = 30 / d;
            points[i].x = clampX(points[i].x + ux * f);
            points[i].y = clampY(points[i].y + uy * f);
            points[j].x = clampX(points[j].x - ux * f);
            points[j].y = clampY(points[j].y - uy * f);
          }
        }
        void 0;
      }
      _results = [];
      for (_m = 0, _len = points.length; _m < _len; _m++) {
        _ref1 = points[_m], x = _ref1.x, y = _ref1.y;
        _results.push({
          x: Math.floor(x),
          y: Math.floor(y)
        });
      }
      return _results;
    };
    Map.dist = function(p1, p2) {
      var dx, dy;
      dx = p1.x - p2.x;
      dy = p1.y - p2.y;
      return Math.sqrt(dx * dx + dy * dy);
    };
    Map.Rng = function(strSeed) {
      var a, b, c, ch, i, _i, _ref, _ref1;
      _ref = [0xbeef, 0xdead, 0xb00], a = _ref[0], b = _ref[1], c = _ref[2];
      for (i = _i = 0, _ref1 = strSeed.length; _i < _ref1; i = _i += 1) {
        ch = strSeed.charCodeAt(i);
        a = c ^ (a << 13) ^ (b << 3) ^ ch;
        b = a ^ (b << 15) ^ (c << 2) ^ (ch >> 1);
        c = b ^ (c << 5) ^ (a << 13) ^ ch;
      }
      this.a = a;
      this.b = b;
      return this.c = c;
    };
    Map.Rng.prototype.genInt24 = function() {
      var x;
      this.a = this.a ^ (((this.b << 13) + (this.c * 6823)) | 0);
      this.b = this.b ^ (((this.c << 11) + (this.a * 7727)) | 0);
      this.c = this.c ^ (((this.a << 10) + (this.b * 7549)) | 0);
      x = ((this.a ^ 5297) + (this.b ^ 4447)) | 0;
      return (x * ((x * x) | 0 * 3209 + 3541)) & 0xffffff;
    };
    Map.Rng.prototype.gen = function() {
      return this.genInt24() / 0xffffff;
    };
    Map.Rng.prototype.genRange = function(from, to) {
      return from + this.gen() * (to - from);
    };
    Map.Rng.prototype.genInt = function(limit) {
      return Math.floor(this.gen() * limit);
    };
    Map.Rng.prototype.genIntRange = function(from, to) {
      return this.genInt(to - from) + from;
    };
    Map.squares = new Array(256);
    Map.squares[Map.EMPTY = 0] = {
      color: "#333333"
    };
    Map.squares[Map.CONCRETE = 120] = {
      color: "#a3a3a3",
      toughness: 0.998
    };
    Map.squares[Map.STEEL = 130] = {
      color: "#6f7989",
      toughness: 0.995
    };
    Map.squares[Map.TITANIUM = 131] = {
      color: "#6287b2",
      toughness: 0.999
    };
    Map.squares[Map.GOLD = 132] = {
      color: "#dfbe23",
      toughness: 0.3,
      energy: 300
    };
    Map.squares[Map.LEAD = 133] = {
      color: "#5b7380",
      toughness: 0.35,
      mass: 50
    };
    Map.squares[Map.VOID = 255] = {
      color: "#000000"
    };
    Map.ROCK_STATS = [
      {
        toughness: 0.4,
        energy: 80,
        prob: 0.5
      }, {
        toughness: 0.5,
        mass: 30,
        prob: 0.4
      }, {
        toughness: 0.6,
        energy: 90,
        prob: 0.4
      }, {
        toughness: 0.5,
        energy: 60,
        prob: 0.3
      }, {
        toughness: 0.5,
        energy: 100,
        prob: 0.3
      }, {
        toughness: 0.4,
        mass: 10,
        prob: 0.6
      }
    ];
    Map.ROCK_COLORS = [["#a39c89", "#a79f8c", "#aaa18b", "#aea287", "#a79b7e", "#a69b83"], ["#a39e89", "#a7a189", "#a09a80", "#999584", "#a09c88", "#a5a08a"], ["#958476", "#8f7d6f", "#988473", "#9d8878", "#a68f7d", "#a79281"], ["#aa9c74", "#a89a72", "#ac9e76", "#ae9e75", "#a99b76", "#aea07b"], ["#b4b1a2", "#b8b5a4", "#bdbaa8", "#bdb9a5", "#bab69f", "#b4b19a"], ["#b6b19d", "#bab5a2", "#bfbaa5", "#bfbaa3", "#c3bea9", "#bdb8a3"]];
    Map.ROCK_TYPE_COUNT = 6;
    Map.ROCK_TYPE_SIZE = 6;
    Map.rockId = function(type, i) {
      return 10 + 10 * type + i;
    };
    for (t = _i = 0, _ref = Map.ROCK_TYPE_COUNT; _i < _ref; t = _i += 1) {
      for (i = _j = 0, _ref1 = Map.ROCK_TYPE_SIZE; _j < _ref1; i = _j += 1) {
        Map.squares[Map["ROCK_" + t + "_" + i] = Map.rockId(t, i)] = {
          color: Map.ROCK_COLORS[t][i],
          toughness: Map.ROCK_STATS[i].toughness,
          energy: Map.ROCK_STATS[i].energy,
          mass: Map.ROCK_STATS[i].mass,
          prob: Map.ROCK_STATS[i].prob
        };
      }
    }
    return Map;
  });

}).call(this);
